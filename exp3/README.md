# Experiment 3
### 实验目的

本实验的主要目的是：
* 增进各位对二叉树数据结构的理解；
* 熟练掌握层序遍历等多种遍历方式；
* 锻炼各位同学编写递归函数的能力。

### 思路详解
题目的第一句话就是：“树由以下字符串递归地描述”。所以这里其实已经给出提示了：本题的预期解法是使用递归解决问题。

所以递归该怎么写呢？

首先我们可以发现，整个树和每一棵子树都被分为三部分：左子树、右子树个根节点。左子树和右子树都用花括号进行分隔。所以一个最自然的想法就是：搞字符串切割。首先用栈搞一个括号匹配，然后切分出左子树和右子树，递归完成建树操作。

然而这种做法明显不行。为什么？

首先，每一趟括号匹配和字符串切割都是O(n)的时间复杂度。假如树很不平衡，深度过大，这肯定吃不消。其次，我们需要空间来存放切割后的字符串，这会增大空间开销。

所以怎么办？

事实上，可以用栈做的东西绝大部分都能用递归做。比如括号匹配也可以用递归做，每一层括号是一层递归函数。所以一个思路就是将建树的过程融入括号匹配的过程中。而且根据上面的分析，搞字符串切割是不行的，所以我们就得用指针完成操作。注意：这里的“指针”是个抽象概念，可以用C语言的指针实现，也可以用数组下标实现。
具体思路是：

* 如果指针位置见到一个左括号，进入下一层递归，指针前进一位。
* 如果指针位置见到一个数字，进行atoi转换，将后面的一段字符串转为数字。指针移动到数字末尾。因为数字末尾后还有一个逗号，所以指针再前进一位。
* 如果指针位置见到一个右括号，函数返回根节点地址，指针前进。上层函数将返回的根节点地址作为左子树/右子树的地址。

具体代码如下。scanPos是上面说的指针。初始需传入一个为0的变量。
```
node* construct(char* inputStr, int &scanPos)
{
	// inputStr[scanPos] is '{'
	scanPos++;	//skip the '{'
	if (inputStr[scanPos] == '}')
	{
		scanPos++;
		return NULL;
	}
	auto subTree = new node;

	// lchild
	subTree->lchild = construct(inputStr, scanPos);
	scanPos++;	//skip the comma
	
	// number
	subTree->data = atoi(inputStr + scanPos);
	while (isdigit(inputStr[scanPos]))
		scanPos++;
	scanPos++;	//skip the comma

	//rchild
	subTree->rchild = construct(inputStr, scanPos);
	return subTree;
}
```
可以看到，这部分逻辑其实比较对称，而且代码量并不大，二十行足够完成任务。

至于树的先序遍历、层序遍历等内容，由于课上讲的较多，在此不多赘述。具体请看助教写的示例代码。

层序遍历我写的比较傻，用两个队列来回倒实现了每层数量的统计。

在示例代码里，为了提高效率，手写了一个非常简陋的静态队列。其接口除了init之外，与STL完全相同。

有的同学层序遍历写的很漂亮，有兴趣的同学可以学习一下。

### 扩展知识
在编译原理里，我们把这种思路叫做“自顶向下翻译”。C语言中变量、函数等的定义和题中树的定义有很大共通之处：它们都能用递归来进行定义。C语言编译器的主要思路和这个也是一样的，只不过结构比这个复杂的多：运算符优先级、函数与变量的声明与定义都可以用这种思路进行翻译。